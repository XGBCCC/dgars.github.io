---
layout: post
title: 算法4-第四章 字符串
category: tech
tag: 算法
---

### 字符串

#### 5.1 字符串排序
`键索引计数法`：简单说用字符串对应的key，生成数组，然后遍历字符串的时候，对应数组对应的key的索引+1。这样就可计算字符串出现的频率
`低位优先字符串排序`：从字符串末尾开始进行一个个对比，并用 键索引计数法 进行索引排序回写，具体可参考下图
![](http://qiniucdn.dgars.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-24%20%E4%B8%8B%E5%8D%8811.43.36.png)
`高位优先的字符串排序`:从字符串首字母开始一个个进行排序，大致算法同`低位优先字符串排序`，不同的是，比较出大小的字符串就不用再进行比较了，如下图所示：
![](http://qiniucdn.dgars.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-24%20%E4%B8%8B%E5%8D%8811.49.27.png)
`三向字符串排序`：类似于排序中的三分取样，取个key，然后将小于,等于,大于整个字符串的数组分为三分，然后再分别进行高位优先字符串排序，如下图所示：
![](http://qiniucdn.dgars.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-24%20%E4%B8%8B%E5%8D%8811.52.23.png)

#### 5.2 单词查找树
##### 5.2.1 单词查找树
类似于二叉树查找，但是每个节点多了个索引值，如果该节点有索引值，则表示从根节点到该节点是个字符串，如图所示：
![](http://qiniucdn.dgars.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-27%20%E4%B8%8A%E5%8D%889.34.36.png)

##### 5.2.2 三向单词查找树
主要是为了避免单词查找树过度的空间消耗。
在三向单词查找树中，每个结点都含有一个字符、三条链接和一个值。这三条链接分 别对应着当前字母小于、等于和大于结点字母的所有键，具体结构如下图所示：
![](http://qiniucdn.dgars.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-27%20%E4%B8%8A%E5%8D%889.43.50.png)

#### 5.3 子字符串查找

举例来说，有一个字符串"BBC ABCDAB ABCDABCDABDE"，我想知道，里面是否包含另一个字符串"ABCDABD"？

##### 5.3.2 暴力查找
简单说就是一个个字母进行匹配，如果发现不匹配，则后移一位后继续该操作，如下图所示：
![](http://qiniucdn.dgars.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-04-27%20%E4%B8%8B%E5%8D%885.27.40.png)
##### 5.3.3 KMP算法
简单说，就是我们比较两个字符串，之前比较过的内容我们是知道的，所以，不需要再重新进行比较，直接将字符串移动到一个合适的位置，然后接着比较后面的即可(从 12312345 中找1234,我们最开始肯定会比较前面的123跟1234，结果最后一个不匹配，按暴力查找的花，我们要从2的位置开始再次跟1234比较，但其实前面123的内容我们已经知道且不符合要求，所以可以直接跨过前面的123，直接比较后面的12345 跟1234 即可)。

参考：[字符串匹配的KMP算法](http://www.ruanyifeng.com/blog/2013/05/Knuth%E2%80%93Morris%E2%80%93Pratt_algorithm.html#comment-text)

##### 5.3.4 Boyer-Moore算法
粗略的理解：先将要比较的字符串与搜索词的头部对其，从结尾开始对比，如果不匹配，且结尾的字母不包含再搜索词中则直接将搜索词移动到当前结尾的字母后面，如果不匹配，但是结尾的字母包含在搜索词中，如果包含则将搜索词的位置移动到该位置，然后再从最右边开始一个个对比。如果搜索词的结尾跟字符串相同，则一个个向前比较，然后再按上述规则进行移动。

参考：[字符串匹配的Boyer-Moore算法](http://www.ruanyifeng.com/blog/2013/05/boyer-moore_string_search_algorithm.html)

##### 5.3.5 Rabin-Karp指纹字符串查找算法
简单理解就是字符串有个散列值，然后从目标字符串按暴力查找的逻辑计算散列值，然后进行对比，发现匹配即找到


#### 5.4 正则表达式
 
 ABCAE
 BCA
