---
layout: post
title: 信息的表示和处理
category: tech
tag: 深入理解计算机系统
---

#### 信息存储
大多数计算机用8位的块，或者字节，作为最小的可寻址的存储器单位，为不实在存储器中单独访问的位

##### 整数的表示
`有符号`:我们默认使用的都是有符号的(有正负)，例如:int i = -1
`无符号`:没有负数，只有正数,例如：unsigned i = 1

`有符号`的最高位表示正负(1表示负数，0表示正数),其余的就正常运算。由于有符号比无符号的多了一位表示位数的，所以，最大值是无符号的一半减1，最小值是无符号的一半

`原码`：原始的二进制（最高位为符号位）
`反码`：正数的的反码是其本身，负数除最高位外，其余位取反
`补码`：正数的本身就是其补码，负数的补码就是符号为不变，其余位取反，最后+1（其实就是取反码然后+1）
`注意`：有符号数-1的二进制表示为：1000 0001 但是在计算机中，我们看到的二进制却是1111 1111，这是因为计算机是以`补码`的形式来表示的

`数字，字母其实就是按照其2进制的表示，直接映射在对应的虚拟内存地址中，所以我们平时打印某个数字的二进制的时候，不论在什么环境下地址都是一样的`

`有符号强转为无符号`:直接按二进制的值来读取就可以了
`无符号强转为有符号`:因为有符号的在计算机上表示的都是补码，所以，我们解析出补码的原码，然后按有符号的二进制读取方式即可（最高位表示正负，其余正常的二进制计算）

`有符号的int的范围，最小值为何比最大值多了1个-128,127`：主要是因为：有符号的1000 0000 与 0000 0000 分辨表示了 +-0，这并没有什么意义，所以，**就将-0表示成-128.(即：1000 0000 表示为-128 )**. 最大补码表示为：0111 1111，最小补码表示为：1000 0000

`计算机如何进行加减法运算`：二进制的加减法都是使用补码来进行计算的(因为：原码不能计算减法，反码又存在+-0的问题，所以就有了补码(就是反码+1))

```
//1-1=0   1+(-1)=0  （十进制）
[0000 0001](原码) + [1000 0001](原码) = [0000 0001](补码) + [1111 1111](补码) = [1 0000 0000](溢出了，最高位就抛弃了) = [0000 0000](补码) = [0000 0000](反码) = [0000 0000](原码)  = 0(十进制)

//1-2=-1   1+(-2)=-1  （十进制）
[0000 0001](原码) + [1000 0010](原码) = [0000 0001](补码) + [1111 1110](补码) = [1111 1111](补码) = [1111 1110](补码-1=反码) = [1000 0001](原码)) = -1(十进制)

//1+2=3   （十进制）
[0000 0001](原码) + [0000 0010](原码) = [0000 0001](补码) + [0000 0010](补码) = [0000 0011](补码) = [0000 0011](反码) = [0000 0011](原码)= 3(十进制)


//2-1=1  2+（-1）=1 （十进制）
[0000 0010](原码) + [1000 0001](原码) = [0000 0010](补码) + [1111 1111](补码) = [1 0000 0001](溢出了，最高位就抛弃了)[补码] = [0000 0001](补码) = [0000 0001](反码) = [0000 0001](原码) = 1(十进制)

```

##### 参考
[原码, 反码, 补码 详解](http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)
[C语言有符号数与无符号数之间的转换](http://www.cnblogs.com/lknlfy/archive/2013/04/02/2996320.html)
[为什么8位有符号类型的数值范围是-128~127](https://www.jianshu.com/p/0ad27ad30a43)
[深入理解计算机系统（2.4）------整数的表示（无符号编码和补码编码）](http://www.cnblogs.com/ysocean/p/7531660.html)
[关于有符号数和无符号数的转换](https://www.cnblogs.com/tgycoder/p/4218696.html)
[http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html](http://www.cnblogs.com/zhangziqiu/archive/2011/03/30/ComputerCode.html)


#### 整数运算
`加法`：补码相加
`减法`：转换为加法，也是补码相加
`乘法`:编译器会现将乘法重写，然后通过左位移+加法来实现，例如：

```
//X*14
14 = 2的3次方+2的2次方+1的一次方
这样编译器就可以将乘法重写为
X<<3 + x<<2 + x<<1
这样，位移后，再进行加法即可
```

`逻辑移位`：不管是左移位还是右移位,都是空缺处补0   
`算数移位`：要保证符号位的不改变（逻辑左移位补0,逻辑右移位看符号位，符号位是1则补1，符号位是0则补0）**算数右移，如果是负数填充1的原因是，计算机表示的是反码，1真正的二进制其实是0**


`除法`：类似乘法,只是将左位移改成了右位移(对于除以 2 的幂可以用移位来运算。无符号除法使用逻辑移位，补码除法使用算术移位。)，例如：

```
无符号：16/8=2
2^3=8 //所以直接右移3位即可
[0001 0000]>>3 = [0000 0010] = 2

有符号：-16/8 = -2
2^3=8
[1111 0000](补码)=> 算数移位>>>3  = [1111 1110](补码) => [1111 1101](反码) =>[1000 0010](原码) = -2

有符号：16/8 = -2
2^3=8
[0001 0000](补码)=> 算数移位>>>3  = [0000 0010](补码) => [0000 0010](反码) =>[0000 0010](原码) = 2
```

*逻辑移位出现小数，总是舍入到零，比如 7/2应该是 3，而不是4*

#### 浮点数