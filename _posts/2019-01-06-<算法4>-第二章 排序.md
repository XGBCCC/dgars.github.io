
---
layout: post
title: <算法4>-第二章 排序
category: tech
tag: 算法
---


### 排序

#### 2.1 初级排序

##### 2.1.2 选择排序

`基本思路:`遍历数组依次找到最小的，放入队列的前面即可。

代码示例:
```
public class Selection {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(a[j], a[min])) min = j;
                exch(a, i, min);
            }
        }
    }
}

```

##### 2.1.3 插入排序
`基本思路:`根据索引遍历数组，发现右边的比左边的小，则直接调换位置。发现右边>=左边的后，则停止对比（因为左边的已经是从小到大排列好的了）

代码示例：
```
public class Insertion {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++) {
            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                exch(a, j, j - 1);
            }
        }
    }

}
```

##### 2.1.6 希尔排序
`基本思想：`主要是在插入排序的基础上，减少对比替换的次数。
例如：插入排序如果最小数放在最末尾，则排序替换的时候需要执行N次，才能替换成功，希尔排序是将原数组拆分成多个数组，然后分别进行插入排序，并确保小数在前，大数灾后，以此来减少对比替换次数。
例如：有数组[3,4,1,6,8,7,5,29,10],可以将其拆分为3列：
```
3  4  1  8
7  5  29 10
```
然后一列一列进行插入排序[3,8,29],[4,7,10],[1,5]，这样就确保了，所有的小数在数组前列，大数都在后列。这样就为之后的排序减少了很多对比交换
```
3  4
1  8
7  5
29 10
```
可以按此进行多次拆分,直到最后只剩下一列，然后进行正常的插入排序，即可完成整个排序
```
1  4
3  5
7  8
29 10
```
```
1
4
3
5
7
8
29
10
```

代码示例：
```
public class Shell {

    public static void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 3) h = 3 * h + 1;
        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h)
                    exch(a, j, j - h);
            }
            h = h / 3;
        }
    }
}
```



公用的基础的比较替换方法
```
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
```