---
layout: post
title: 算法4-第二章-排序
category: tech
tag: 算法
---


### 排序

#### 2.1 初级排序

##### 2.1.2 选择排序

`基本思路:`遍历数组依次找到最小的，放入队列的前面即可。

代码示例:
```
public class Selection {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 0; i < N; i++) {
            int min = i;
            for (int j = i + 1; j < N; j++) {
                if (less(a[j], a[min])) min = j;
                exch(a, i, min);
            }
        }
    }
}

```

##### 2.1.3 插入排序
`基本思路:`根据索引遍历数组，发现右边的比左边的小，则直接调换位置。发现右边>=左边的后，则停止对比（因为左边的已经是从小到大排列好的了）

代码示例：
```
public class Insertion {
    public static void sort(Comparable[] a) {
        int N = a.length;
        for (int i = 1; i < N; i++) {
            for (int j = i; j > 0 && less(a[j], a[j - 1]); j--) {
                exch(a, j, j - 1);
            }
        }
    }

}
```

##### 2.1.6 希尔排序
`基本思想：`主要是在插入排序的基础上，减少对比替换的次数。
例如：插入排序如果最小数放在最末尾，则排序替换的时候需要执行N次，才能替换成功，希尔排序是将原数组拆分成多个数组，然后分别进行插入排序，并确保小数在前，大数灾后，以此来减少对比替换次数。
例如：有数组[3,4,1,6,8,7,5,29,10],可以将其拆分为3列：
```
3  4  1  8
7  5  29 10
```
然后一列一列进行插入排序[3,8,29],[4,7,10],[1,5]，这样就确保了，所有的小数在数组前列，大数都在后列。这样就为之后的排序减少了很多对比交换
```
3  4
1  8
7  5
29 10
```
可以按此进行多次拆分,直到最后只剩下一列，然后进行正常的插入排序，即可完成整个排序
```
1  4
3  5
7  8
29 10
```
```
1
4
3
5
7
8
29
10
```

代码示例：
```
public class Shell {

    public static void sort(Comparable[] a) {
        int N = a.length;
        int h = 1;
        while (h < N / 3) h = 3 * h + 1;
        while (h >= 1) {
            for (int i = h; i < N; i++) {
                for (int j = i; j >= h && less(a[j], a[j - h]); j -= h)
                    exch(a, j, j - h);
            }
            h = h / 3;
        }
    }
}
```



公用的基础的比较替换方法
```
    private static boolean less(Comparable v, Comparable w) {
        return v.compareTo(w) < 0;
    }

    private static void exch(Comparable[] a, int i, int j) {
        Comparable t = a[i];
        a[i] = a[j];
        a[j] = t;
    }
```


#### 2.2 归并排序
##### 2.2.1 原地归并的抽象方法
主要思想：将一个数组拆分为多个数组，之后在进行合并排序
示例代码：
```
public static void merge(Comparable[] a, int lo, int mid, int hi) {
        int i = lo, j = mid + 1;
        Comparable[] aux = new Comparable[hi - 1]; //首先将数组统一复制到aux中
        for (int k = lo; k < hi; k++) {
            aux[k] = a[k];
        }

        for (int k = lo; k < hi; k++) {  //遍历所有数据
            if (i > mid) a[k] = aux[j++]; //如果左边的数组用完了，则直接将右边的数组填入
            else if (j > hi) a[k] = aux[i++]; //如果右边的数组用完了，则直接将左边的数组填入
            else if (less(aux[j], aux[i])) a[k] = aux[j++]; //如果两边数组都还没用完，则对比当前左右两边第一个数据的大小，填入小的
            else a[k] = aux[i++];
        }
    }
```

##### 2.2.2 自顶向下的归并排序
递归将大数组拆分为小数组，并将小数组逐步递归合并排序为大数组

示例代码：
```
    public static void sort(Comparable[] a) {
        aux = new Comparable[a.length];
        sort(a, 0, a.length - 1);
    }

    public static void sort(Comparable[] a, int lo, int hi) {
        if (hi <= lo) return;
        int mid = lo + (hi - lo) / 2;
        sort(a, lo, mid);
        sort(a, mid + 1, hi);
        merge(a, lo, mid, hi);
    }
```

##### 2.2.3 自低向上的归并排序
两两数组归并排序，再四四数组合并，如此最终合并所有数组
示例：
```
    public static void sort(Comparable[] a) {
        int N = a.length;
        aux = new Comparable[N];
        for (int sz = 1; sz < N; sz = sz + sz) {
            for (int lo = 0; lo < N - sz; lo += sz + sz) {
                merge(a, lo, lo + sz - 1, Math.min(lo + sz + sz - 1, N - 1));
            }
        }
    }
```
