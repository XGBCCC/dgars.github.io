---
layout: post
title: 虚拟内存
category: tech
tag: 深入理解计算机系统
--- 

虚拟内存是单机系统最重要的几个底层原理之一，它由底层硬件和操作系统两者软硬件结合来实现，是硬件异常，硬件地址翻译，主存，磁盘文件和内核的完美交互。它主要提供了3个能力：
1. 给所有进程提供一致的地址空间，每个进程都认为自己是在独占使用单机系统的存储资源
2. 保护每个进程的地址空间不被其他进程破坏，隔离了进程的地址访问
3. 根据缓存原理，上层存储是下层存储的缓存，虚拟内存把主存作为磁盘的高速缓存，在主存和磁盘之间根据需要来回传送数据，高效地使用了主存

#### 9.1 物理和虚拟寻址
CPU->虚拟地址->地址翻译->物理内存地址

#### 9.2 地址空间
#### 9.3 虚拟内存作为缓存的工具
1. CPU要找一个虚拟地址
2. 内存中有一个虚拟地址的对应表
3. 在表中找有没有存过这个虚拟地址
    4. 如果有存过，则直接找到对应的内存地址取找
    5. 如果没存过，则从硬盘加载到内存，并放到虚拟地址表中
4. 然后就加载到数据了

#### 9.4 虚拟内存作为内存管理的工具
因为所有的内存都是统一的，所以简化了各种加载，链接，共享，内存分配.
所以我们才可以方便的用dsym来解析crash

#### 9.5 虚拟内存作为内存保护的工具
虚拟内存的对照表内部有各种标记权限的东西，防止恶意访问

#### 9.6 地址翻译
![](http://7xjcm6.com1.z0.glb.clouddn.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202018-08-18%20%E4%B8%8B%E5%8D%888.44.39.png)

#### 9.8 内存映射
虚拟内存映射对应磁盘/内存的具体地址
mmap可以创建一个虚拟内存区域（mmap可以将数据时时写入磁盘应该也是这么干的，因为虚拟内存跟磁盘是有对应关系的）

#### 9.9 动态内存分配
`显式分配`:malloc,free
`隐式分配`:垃圾回收
`内存对齐`：现代计算机中内存空间都是按照 byte 划分的，从理论上讲似乎对任何类型的变量的访问可以从任何地址开始，但实际情况是在访问特定类型变量的时候经常在特定的内存地址访问，这就需要各种类型数据按照一定的规则在空间上排列，而不是顺序的一个接一个的排放，这就是对齐。
举一个简单的例子，uint32_t所占内存空间为 4 bytes，char为 1 byte。如果把它们放在一个结构体中，则所占的内存空间应该是 4 + 1 = 5 bytes 。而事实上，在VS2012和gcc环境下，sizeof 操作的结果都是 8 bytes
所以会有一些内存没有使用。
碎片化，可能我们会free某些对象，然后就导致中间空出来，之后要填充的对象也不会一定可以完全填充

#### 9.10 垃圾回收
自动调用free

#### 9.11 C程序中常见的与内存有关的错误
1. 间接引用坏指针
2. 读未初始化的内存
3. 允许栈缓存区溢出（要存入的大小超过了分配的大小）
4. 假设指针和他们指向的对象是相同大小的（类型强转）
5. 造成错位错误（数组越界）
6. 引用指针，而不是它指向的对象
7. 误解指针运算
8. 引用不存在的地址
9. 引用已释放的内存
10 内存泄漏

###### 其他
如果计算机缺少运行程序或操作所需的随机存取内存 (RAM)，则 系统使 用虚拟内存进行补偿。 
虚拟内存将计算机的 RAM 和硬盘上的临时空间组合在一起。当 RAM 运行速 度缓慢时，虚拟内存将数据从 RAM 移动到称为“分页文件”的空间中。将数据移入与 移出分页文件可以释放 RAM，以便完成工作。 